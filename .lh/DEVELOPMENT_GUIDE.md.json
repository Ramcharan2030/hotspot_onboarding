{
    "sourceFile": "DEVELOPMENT_GUIDE.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1762892191597,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1762892191597,
            "name": "Commit-0",
            "content": "# Development Workflow & Best Practices\r\n\r\n## Feature Development Checklist\r\n\r\nWhen starting a new feature, follow this checklist:\r\n\r\n### 1. **Plan the Feature Structure**\r\n```\r\n✓ Define feature name and scope\r\n✓ Identify required models and data structures\r\n✓ Plan state management needs (providers)\r\n✓ Design UI screens and components\r\n✓ Identify reusable vs. feature-specific widgets\r\n```\r\n\r\n### 2. **Create Feature Directory**\r\n```bash\r\nmkdir -p lib/features/my_feature/{data,presentation,provider}\r\n\r\n# Create subdirectories\r\nmkdir -p lib/features/my_feature/presentation/widgets\r\n```\r\n\r\n### 3. **Implement in Order**\r\n```\r\n1. Models (data/)\r\n   └─ {feature}_model.dart - Define data structures\r\n\r\n2. Services (data/)\r\n   └─ {feature}_service.dart - API/device interactions\r\n\r\n3. State Management (provider/)\r\n   └─ {feature}_provider.dart - Riverpod providers\r\n\r\n4. Widgets (presentation/widgets/)\r\n   └─ {component}_widget.dart - Reusable components\r\n   └─ {button}_button.dart - Custom buttons\r\n\r\n5. Screens (presentation/)\r\n   └─ {feature}_screen.dart - Main screen\r\n```\r\n\r\n### 4. **Write Documentation**\r\n```dart\r\n/// Model representing user experience preferences.\r\nclass ExperienceModel {\r\n  /// Unique identifier for the experience\r\n  final String id;\r\n\r\n  /// Display name of the experience\r\n  final String name;\r\n\r\n  ExperienceModel({\r\n    required this.id,\r\n    required this.name,\r\n  });\r\n}\r\n```\r\n\r\n### 5. **Test Integration**\r\n```\r\n✓ Test with hot reload\r\n✓ Test state persistence\r\n✓ Test error scenarios\r\n✓ Test animations and UI transitions\r\n✓ Test on different screen sizes\r\n```\r\n\r\n---\r\n\r\n## State Management (Riverpod) Best Practices\r\n\r\n### ✅ DO\r\n\r\n```dart\r\n// ✓ DO: Use StateNotifierProvider for mutable state\r\nfinal userProvider = StateNotifierProvider<\r\n  UserNotifier,\r\n  UserState\r\n>((ref) => UserNotifier());\r\n\r\n// ✓ DO: Keep notifiers pure and testable\r\nclass UserNotifier extends StateNotifier<UserState> {\r\n  UserNotifier() : super(UserState.initial());\r\n\r\n  void updateName(String name) {\r\n    state = state.copyWith(name: name);\r\n  }\r\n}\r\n\r\n// ✓ DO: Use FutureProvider for async data\r\nfinal userDataProvider = FutureProvider<UserData>((ref) async {\r\n  return await fetchUserData();\r\n});\r\n\r\n// ✓ DO: Use .select() to watch specific fields\r\nfinal userName = ref.watch(\r\n  userProvider.select((state) => state.name)\r\n);\r\n\r\n// ✓ DO: Properly invalidate providers when needed\r\nref.invalidate(userProvider);\r\n```\r\n\r\n### ❌ DON'T\r\n\r\n```dart\r\n// ✗ DON'T: Access notifier in build method\r\nfinal state = ref.read(userProvider.notifier).state;\r\n\r\n// ✗ DON'T: Mutate state directly\r\nstate.name = 'John'; // Wrong\r\n\r\n// ✗ DON'T: Create providers in build method\r\n@override\r\nWidget build(BuildContext context) {\r\n  final provider = StateNotifierProvider(...); // Wrong\r\n}\r\n\r\n// ✗ DON'T: Use .watch in event handlers\r\nonPressed: () => ref.watch(userProvider), // Wrong - use .read()\r\n```\r\n\r\n---\r\n\r\n## Widget Composition Patterns\r\n\r\n### Pattern 1: Reusable Button\r\n```dart\r\nclass PrimaryButton extends StatelessWidget {\r\n  final String label;\r\n  final VoidCallback onPressed;\r\n  final bool isLoading;\r\n\r\n  const PrimaryButton({\r\n    super.key,\r\n    required this.label,\r\n    required this.onPressed,\r\n    this.isLoading = false,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return GestureDetector(\r\n      onTap: isLoading ? null : onPressed,\r\n      child: Container(\r\n        padding: const EdgeInsets.symmetric(\r\n          horizontal: 24,\r\n          vertical: 12,\r\n        ),\r\n        decoration: BoxDecoration(\r\n          borderRadius: BorderRadius.circular(8),\r\n          color: isLoading ? Colors.grey : Colors.blue,\r\n        ),\r\n        child: isLoading\r\n            ? const SizedBox(\r\n                width: 20,\r\n                height: 20,\r\n                child: CircularProgressIndicator(\r\n                  strokeWidth: 2,\r\n                  valueColor: AlwaysStoppedAnimation(Colors.white),\r\n                ),\r\n              )\r\n            : Text(label),\r\n      ),\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n### Pattern 2: Animated Card with Interaction\r\n```dart\r\nclass AnimatedCard extends StatefulWidget {\r\n  final Widget child;\r\n  final VoidCallback onTap;\r\n  final bool isSelected;\r\n\r\n  const AnimatedCard({\r\n    super.key,\r\n    required this.child,\r\n    required this.onTap,\r\n    this.isSelected = false,\r\n  });\r\n\r\n  @override\r\n  State<AnimatedCard> createState() => _AnimatedCardState();\r\n}\r\n\r\nclass _AnimatedCardState extends State<AnimatedCard>\r\n    with SingleTickerProviderStateMixin {\r\n  late AnimationController _controller;\r\n\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    _controller = AnimationController(\r\n      duration: const Duration(milliseconds: 300),\r\n      vsync: this,\r\n    );\r\n    if (widget.isSelected) _controller.forward();\r\n  }\r\n\r\n  @override\r\n  void didUpdateWidget(AnimatedCard oldWidget) {\r\n    super.didUpdateWidget(oldWidget);\r\n    if (widget.isSelected) {\r\n      _controller.forward();\r\n    } else {\r\n      _controller.reverse();\r\n    }\r\n  }\r\n\r\n  @override\r\n  void dispose() {\r\n    _controller.dispose();\r\n    super.dispose();\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return GestureDetector(\r\n      onTap: widget.onTap,\r\n      child: ScaleTransition(\r\n        scale: Tween<double>(begin: 1.0, end: 1.1)\r\n            .animate(CurvedAnimation(parent: _controller, curve: Curves.easeInOut)),\r\n        child: widget.child,\r\n      ),\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n### Pattern 3: Form Validation\r\n```dart\r\nclass FormField<T> extends StatefulWidget {\r\n  final String label;\r\n  final String Function(T)? validator;\r\n  final ValueChanged<T> onChanged;\r\n\r\n  const FormField({\r\n    super.key,\r\n    required this.label,\r\n    this.validator,\r\n    required this.onChanged,\r\n  });\r\n\r\n  @override\r\n  State<FormField<T>> createState() => _FormFieldState<T>();\r\n}\r\n\r\nclass _FormFieldState<T> extends State<FormField<T>> {\r\n  String? _error;\r\n\r\n  void _validate(T value) {\r\n    setState(() {\r\n      _error = widget.validator?.call(value);\r\n    });\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Column(\r\n      crossAxisAlignment: CrossAxisAlignment.start,\r\n      children: [\r\n        Text(widget.label),\r\n        TextField(\r\n          onChanged: (value) {\r\n            widget.onChanged(value as T);\r\n            _validate(value as T);\r\n          },\r\n        ),\r\n        if (_error != null)\r\n          Padding(\r\n            padding: const EdgeInsets.only(top: 8),\r\n            child: Text(\r\n              _error!,\r\n              style: const TextStyle(color: Colors.red),\r\n            ),\r\n          ),\r\n      ],\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Performance Optimization Tips\r\n\r\n### 1. **Rebuild Optimization with .select()**\r\n```dart\r\n// ✗ Bad: Rebuilds when ANY state changes\r\nfinal state = ref.watch(userProvider);\r\n\r\n// ✓ Good: Rebuilds only when name changes\r\nfinal userName = ref.watch(\r\n  userProvider.select((state) => state.name)\r\n);\r\n```\r\n\r\n### 2. **Const Widgets**\r\n```dart\r\n// ✓ GOOD: Mark widgets as const\r\nconst SizedBox(height: 16);\r\nconst Icon(Icons.check);\r\n\r\n// ✓ GOOD: Use const constructors\r\nconst EdgeInsets.symmetric(horizontal: 16);\r\n\r\n// Automatically rebuild child widgets less\r\n```\r\n\r\n### 3. **Lazy Initialization**\r\n```dart\r\n// ✓ GOOD: Use autoDispose for temporary providers\r\nfinal tempProvider = StateNotifierProvider.autoDispose<...>(...);\r\n\r\n// ✓ GOOD: Lazy instantiation of expensive objects\r\nlate final ExpensiveService _service;\r\n\r\n@override\r\nvoid initState() {\r\n  super.initState();\r\n  _service = ExpensiveService(); // Only when needed\r\n}\r\n```\r\n\r\n### 4. **Image Optimization**\r\n```dart\r\n// ✓ GOOD: Cache network images\r\nImage.network(\r\n  imageUrl,\r\n  cacheWidth: 400,\r\n  cacheHeight: 400,\r\n  fadeInDuration: const Duration(milliseconds: 200),\r\n)\r\n\r\n// ✓ GOOD: Use cached_network_image package\r\nCachedNetworkImage(\r\n  imageUrl: imageUrl,\r\n  placeholder: (context, url) => Container(color: Colors.grey),\r\n  errorWidget: (context, url, error) => const Icon(Icons.error),\r\n)\r\n```\r\n\r\n---\r\n\r\n## Debugging Tips\r\n\r\n### 1. **Enable Riverpod Logging**\r\n```dart\r\nProviderContainer(\r\n  observers: [\r\n    RiverpodObserver(),\r\n  ],\r\n)\r\n```\r\n\r\n### 2. **Use DevTools**\r\n```bash\r\n# Launch Flutter DevTools\r\nflutter pub global activate devtools\r\ndevtools\r\n\r\n# Connect to running app\r\nflutter run --enable-software-animation\r\n```\r\n\r\n### 3. **Print State Changes**\r\n```dart\r\nclass OnboardingNotifier extends StateNotifier<OnboardingState> {\r\n  @override\r\n  set state(OnboardingState value) {\r\n    print('State changed from: $state → $value');\r\n    super.state = value;\r\n  }\r\n}\r\n```\r\n\r\n### 4. **Inspect Widget Tree**\r\n```dart\r\n@override\r\nWidget build(BuildContext context) {\r\n  // Use DevTools -> Inspector to inspect widget tree\r\n  return Scaffold(\r\n    // ...\r\n  );\r\n}\r\n```\r\n\r\n---\r\n\r\n## Testing Guidelines\r\n\r\n### Unit Tests (Services & Providers)\r\n```dart\r\ntest('AudioRecordService should record audio', () async {\r\n  final service = AudioRecordService();\r\n  final path = await service.record(path: 'test.m4a');\r\n  \r\n  expect(path, isNotNull);\r\n  expect(File(path).existsSync(), true);\r\n});\r\n\r\ntest('OnboardingNotifier should update state on recording', () {\r\n  final notifier = OnboardingNotifier();\r\n  notifier.stopAudioRecording('audio.m4a');\r\n  \r\n  expect(notifier.state.audioPath, 'audio.m4a');\r\n});\r\n```\r\n\r\n### Widget Tests (UI Components)\r\n```dart\r\ntestWidgets('ExperienceCard should animate on tap', (WidgetTester tester) async {\r\n  await tester.pumpWidget(\r\n    MaterialApp(\r\n      home: Scaffold(\r\n        body: ExperienceCard(\r\n          experience: mockExperience,\r\n          isSelected: false,\r\n          onTap: () {},\r\n        ),\r\n      ),\r\n    ),\r\n  );\r\n\r\n  await tester.tap(find.byType(ExperienceCard));\r\n  await tester.pumpAndSettle();\r\n\r\n  expect(find.byType(ScaleTransition), findsOneWidget);\r\n});\r\n```\r\n\r\n---\r\n\r\n## Deployment Checklist\r\n\r\nBefore deploying to production:\r\n\r\n- [ ] All print() statements removed or replaced with logging\r\n- [ ] Error handling implemented for all network/device operations\r\n- [ ] No hardcoded URLs or sensitive data\r\n- [ ] All images optimized and compressed\r\n- [ ] Animations tested on low-end devices\r\n- [ ] Permissions properly requested and handled\r\n- [ ] All widgets properly disposed (AnimationController, Stream, etc.)\r\n- [ ] No memory leaks (checked with DevTools memory profiler)\r\n- [ ] Performance acceptable (60 FPS maintained)\r\n- [ ] Accessibility considerations (colors, text size, etc.)\r\n- [ ] Tested on multiple device sizes and OS versions\r\n- [ ] App signing keys secured\r\n- [ ] Analytics properly configured\r\n- [ ] Crash reporting configured (Firebase Crashlytics)\r\n\r\n---\r\n\r\n## Version Control Best Practices\r\n\r\n### Commit Message Format\r\n```\r\n[TYPE] Brief description (50 chars max)\r\n\r\nDetailed explanation of changes (if needed)\r\n\r\nFixes: #123\r\nRelated: #456\r\n```\r\n\r\n### Types\r\n```\r\n[feat]     - New feature\r\n[fix]      - Bug fix\r\n[refactor] - Code restructuring\r\n[style]    - Formatting/style changes\r\n[docs]     - Documentation\r\n[test]     - Test additions/changes\r\n[chore]    - Build/dependency updates\r\n```\r\n\r\n### Example Commits\r\n```\r\n[feat] Add audio recording with playback animation\r\n- Implement AudioRecordService for device recording\r\n- Add immediate playback in onboarding screen\r\n- Animate wave header during recording\r\n\r\n[fix] Handle file URI paths in delete operation\r\n- Normalize file:// URIs before deletion\r\n- Add fallback for alternate path formats\r\n- Add diagnostic logging for debugging\r\n\r\n[refactor] Extract AnimatedRow component\r\n- Move bottom button row to separate widget\r\n- Improve code reusability and testability\r\n- Add proper animation timing\r\n```\r\n\r\n---\r\n\r\n## Code Review Checklist\r\n\r\nWhen reviewing others' code:\r\n\r\n- [ ] Code follows architecture (data/presentation/provider layers)\r\n- [ ] No business logic in UI widgets\r\n- [ ] Error handling is comprehensive\r\n- [ ] Comments are clear and necessary\r\n- [ ] No performance red flags (unnecessary rebuilds, etc.)\r\n- [ ] Type safety maintained\r\n- [ ] Resources properly cleaned up\r\n- [ ] Constants extracted (no magic numbers)\r\n- [ ] Naming follows conventions\r\n- [ ] Functions are single-responsibility\r\n- [ ] Tests cover edge cases\r\n- [ ] Documentation updated if needed\r\n\r\n"
        }
    ]
}