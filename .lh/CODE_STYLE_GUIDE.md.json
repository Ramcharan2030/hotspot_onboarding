{
    "sourceFile": "CODE_STYLE_GUIDE.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1762892129094,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1762892129094,
            "name": "Commit-0",
            "content": "# Code Style & Development Guidelines\r\n\r\n## Dart/Flutter Formatting Standards\r\n\r\n### 1. Code Organization\r\n\r\n```dart\r\n// ✓ GOOD: Clear organization with sections\r\nimport 'package:flutter/material.dart';\r\nimport 'package:google_fonts/google_fonts.dart';\r\n\r\n// --- CONSTANTS ---\r\nconst Color kBackgroundColor = Color(0xFF0B0B0B);\r\nconst double kPaddingHorizontal = 16.0;\r\n\r\n// --- MAIN WIDGET ---\r\nclass MyScreen extends StatelessWidget {\r\n  const MyScreen({super.key});\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Scaffold(\r\n      body: _buildBody(),\r\n    );\r\n  }\r\n\r\n  // --- HELPER METHODS ---\r\n  Widget _buildBody() {\r\n    return Container();\r\n  }\r\n}\r\n\r\n// --- HELPER CLASSES ---\r\nclass _HelperWidget extends StatelessWidget {\r\n  // ...\r\n}\r\n```\r\n\r\n### 2. Naming Conventions\r\n\r\n#### Constants\r\n```dart\r\n✓ const Color kPrimaryColor = Color(0xFF5B7FFF);\r\n✓ const double kPaddingSmall = 8.0;\r\n✓ const String kAppTitle = 'Hotspot';\r\n✓ const Duration kAnimationDuration = Duration(milliseconds: 300);\r\n```\r\n\r\n#### Variables & Functions\r\n```dart\r\n✓ String userName = 'John';              // camelCase\r\n✓ Future<void> fetchUserData() {}        // camelCase\r\n✓ Widget _buildHeader() {}               // Private: underscore prefix\r\n✓ void _handleButtonTap() {}             // Event handlers: _handle prefix\r\n✗ String user_name = 'John';             // snake_case not allowed\r\n✗ String UserName = 'John';              // PascalCase for variables not used\r\n```\r\n\r\n#### Classes & Types\r\n```dart\r\n✓ class UserProfile {}                   // PascalCase\r\n✓ class AudioRecordService {}            // PascalCase\r\n✓ enum RecordingState { idle, recording, paused }  // PascalCase\r\n✗ class userProfile {}                   // Should be PascalCase\r\n```\r\n\r\n### 3. Documentation & Comments\r\n\r\n#### Doc Comments (Public API)\r\n```dart\r\n/// Records audio from the device microphone.\r\n///\r\n/// Returns the file path of the recorded audio.\r\n///\r\n/// Example:\r\n/// ```dart\r\n/// final service = AudioRecordService();\r\n/// final path = await service.recordAudio();\r\n/// ```\r\nFuture<String> recordAudio() async {\r\n  // Implementation\r\n}\r\n```\r\n\r\n#### Inline Comments (Non-obvious logic)\r\n```dart\r\n// ✓ GOOD: Explains WHY, not WHAT\r\n// Delay to allow UI to update before animation starts\r\nFuture.delayed(const Duration(milliseconds: 100), () {\r\n  _animateCard();\r\n});\r\n\r\n✗ BAD: Redundant comments\r\n// Increment counter\r\ncounter++;\r\n\r\n✗ BAD: Outdated comments\r\n// This was a workaround for bug #123 (already fixed)\r\n```\r\n\r\n#### Section Comments\r\n```dart\r\n/// Define clear sections for better code navigation\r\n// --- CONSTANTS ---\r\n// --- STATE VARIABLES ---\r\n// --- LIFECYCLE ---\r\n// --- BUILD METHOD ---\r\n// --- HELPER METHODS ---\r\n// --- ANIMATION CALLBACKS ---\r\n```\r\n\r\n### 4. Widget Structure\r\n\r\n#### StatelessWidget\r\n```dart\r\nclass ExperienceCard extends StatelessWidget {\r\n  final ExperienceModel experience;\r\n  final VoidCallback onTap;\r\n\r\n  const ExperienceCard({\r\n    super.key,\r\n    required this.experience,\r\n    required this.onTap,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return GestureDetector(\r\n      onTap: onTap,\r\n      child: _buildCard(),\r\n    );\r\n  }\r\n\r\n  Widget _buildCard() {\r\n    return Container(\r\n      // Implementation\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n#### StatefulWidget\r\n```dart\r\nclass RecordingScreen extends StatefulWidget {\r\n  const RecordingScreen({super.key});\r\n\r\n  @override\r\n  State<RecordingScreen> createState() => _RecordingScreenState();\r\n}\r\n\r\nclass _RecordingScreenState extends State<RecordingScreen> {\r\n  late AudioRecordService _audioService;\r\n\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    _audioService = AudioRecordService();\r\n    _initializeRecording();\r\n  }\r\n\r\n  @override\r\n  void dispose() {\r\n    _audioService.dispose(); // Always cleanup\r\n    super.dispose();\r\n  }\r\n\r\n  Future<void> _initializeRecording() async {\r\n    // Implementation\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Scaffold(\r\n      body: _buildBody(),\r\n    );\r\n  }\r\n\r\n  Widget _buildBody() {\r\n    // Implementation\r\n  }\r\n}\r\n```\r\n\r\n### 5. Error Handling\r\n\r\n```dart\r\n// ✓ GOOD: Specific error handling with recovery\r\nFuture<void> deleteAudio(String path) async {\r\n  try {\r\n    final file = File(path);\r\n    if (await file.exists()) {\r\n      await file.delete();\r\n      logger.info('Audio deleted: $path');\r\n    } else {\r\n      logger.warn('File not found: $path');\r\n      // Graceful handling\r\n    }\r\n  } catch (e, stackTrace) {\r\n    logger.error('Error deleting audio: $e', stackTrace);\r\n    rethrow; // or handle silently depending on use case\r\n  }\r\n}\r\n\r\n✗ BAD: Bare catch\r\ntry {\r\n  // operation\r\n} catch (e) {\r\n  print(e); // No context, no recovery\r\n}\r\n```\r\n\r\n### 6. Async/Await Best Practices\r\n\r\n```dart\r\n// ✓ GOOD: Use async/await instead of .then()\r\nFuture<void> loadData() async {\r\n  try {\r\n    final data = await fetchFromServer();\r\n    updateUI(data);\r\n  } catch (e) {\r\n    handleError(e);\r\n  }\r\n}\r\n\r\n✗ BAD: Callback hell\r\nFuture<void> loadData() {\r\n  return fetchFromServer().then((data) {\r\n    return updateUI(data);\r\n  }).catchError((e) {\r\n    handleError(e);\r\n  });\r\n}\r\n\r\n// ✓ GOOD: Use Future.wait for parallel operations\r\nFuture<void> initializeServices() async {\r\n  await Future.wait([\r\n    _initAudioService(),\r\n    _initVideoService(),\r\n    _initPermissions(),\r\n  ]);\r\n}\r\n\r\n✗ BAD: Sequential when parallel is possible\r\nawait _initAudioService();\r\nawait _initVideoService();\r\nawait _initPermissions();\r\n```\r\n\r\n### 7. Type Safety\r\n\r\n```dart\r\n// ✓ GOOD: Explicit types\r\nMap<String, List<int>> parseData(String json) {\r\n  // Clear intent\r\n}\r\n\r\n// ✓ GOOD: Type inference where obvious\r\nfinal config = <String, dynamic>{\r\n  'apiUrl': 'https://api.example.com',\r\n  'timeout': 30,\r\n};\r\n\r\n✗ BAD: Dynamic typing\r\ndynamic data = fetchData(); // No type information\r\nvar result = parseJson(data); // Unclear type\r\n\r\n✗ BAD: Using `var` when explicit type is clearer\r\nvar screens = [\r\n  ExperienceScreen(),\r\n  OnboardingScreen(),\r\n]; // Type is unclear\r\n```\r\n\r\n### 8. Collections & Nullability\r\n\r\n```dart\r\n// ✓ GOOD: Use nullable types explicitly\r\nString? getDescription() {\r\n  return _description.isEmpty ? null : _description;\r\n}\r\n\r\n// ✓ GOOD: Null coalescing and null-aware operators\r\nfinal description = user.bio ?? 'No bio provided';\r\nfinal length = user.bio?.length;\r\n\r\n✗ BAD: Unhandled nullability\r\nString getDescription() {\r\n  return _description; // Could be null\r\n}\r\n\r\n// ✓ GOOD: Use List.from() when modifying original list\r\nList<Item> items = fetchItems();\r\nList<Item> sortedItems = List.from(items)..sort();\r\n\r\n✗ BAD: Mutating original list unexpectedly\r\nitems.sort(); // Modifies original\r\n```\r\n\r\n### 9. Constants & Magic Numbers\r\n\r\n```dart\r\n// ✓ GOOD: Extracted constants\r\nconst double kCardAnimationDuration = 400.0;\r\nconst double kCardWidthSelected = 100.0;\r\nconst double kCardWidthDefault = 90.0;\r\n\r\nclass CardWidget extends StatelessWidget {\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return AnimatedContainer(\r\n      duration: Duration(milliseconds: kCardAnimationDuration.toInt()),\r\n      width: isSelected ? kCardWidthSelected : kCardWidthDefault,\r\n      // ...\r\n    );\r\n  }\r\n}\r\n\r\n✗ BAD: Magic numbers scattered in code\r\nduration: const Duration(milliseconds: 400),\r\nwidth: 100,\r\n```\r\n\r\n### 10. Provider Usage (Riverpod)\r\n\r\n```dart\r\n// ✓ GOOD: Clear, testable provider\r\nfinal onboardingProvider = StateNotifierProvider.autoDispose<\r\n  OnboardingNotifier,\r\n  OnboardingState\r\n>((ref) => OnboardingNotifier());\r\n\r\n// ✓ GOOD: Notifier is a plain, testable class\r\nclass OnboardingNotifier extends StateNotifier<OnboardingState> {\r\n  OnboardingNotifier()\r\n      : super(OnboardingState(\r\n          audioPath: null,\r\n          videoPath: null,\r\n          answerText: '',\r\n        ));\r\n\r\n  /// Records audio and updates state\r\n  void stopAudioRecording(String path) {\r\n    state = state.copyWith(audioPath: path);\r\n  }\r\n}\r\n\r\n// ✓ GOOD: Usage in widgets is clear\r\nfinal state = ref.watch(onboardingProvider);\r\nref.read(onboardingProvider.notifier).stopAudioRecording(path);\r\n\r\n✗ BAD: Complex logic in provider\r\nfinal userData = ref.watch(userProvider);\r\n// No clear data flow\r\n```\r\n\r\n---\r\n\r\n## Project-Specific Guidelines\r\n\r\n### 1. Animation Best Practices\r\n\r\n```dart\r\n// ✓ GOOD: Use AnimatedContainer for simple animations\r\nAnimatedContainer(\r\n  duration: const Duration(milliseconds: 400),\r\n  curve: Curves.easeInOut,\r\n  width: isSelected ? 100 : 90,\r\n  child: child,\r\n)\r\n\r\n// ✓ GOOD: Use Transform for rotation\r\nTransform.rotate(\r\n  angle: tiltAngle,\r\n  child: card,\r\n)\r\n\r\n// ✓ GOOD: Use explicit AnimationController when needed\r\nlate AnimationController _controller;\r\n\r\n@override\r\nvoid initState() {\r\n  _controller = AnimationController(\r\n    duration: const Duration(seconds: 3),\r\n    vsync: this,\r\n  )..repeat();\r\n}\r\n\r\n@override\r\nvoid dispose() {\r\n  _controller.dispose(); // Always cleanup\r\n  super.dispose();\r\n}\r\n```\r\n\r\n### 2. Recording Services Pattern\r\n\r\n```dart\r\n// ✓ GOOD: Services encapsulate device interaction\r\nclass AudioRecordService {\r\n  final RecorderController _recorderController;\r\n\r\n  AudioRecordService() : _recorderController = RecorderController();\r\n\r\n  Future<void> initialize() async {\r\n    await _recorderController.checkPermission();\r\n  }\r\n\r\n  Future<String?> record({required String path}) async {\r\n    try {\r\n      await _recorderController.record(path: path);\r\n      return path;\r\n    } catch (e) {\r\n      logger.error('Recording failed: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n\r\n  Future<void> dispose() async {\r\n    await _recorderController.dispose();\r\n  }\r\n}\r\n\r\n// ✓ GOOD: Usage is simple\r\nfinal audioService = AudioRecordService();\r\nawait audioService.initialize();\r\nfinal path = await audioService.record(path: 'audio.m4a');\r\n```\r\n\r\n### 3. File Operations\r\n\r\n```dart\r\n// ✓ GOOD: Robust file handling with path normalization\r\nFuture<void> deleteFile(String filePath) async {\r\n  try {\r\n    String normPath = filePath;\r\n    \r\n    // Handle file:// URIs\r\n    if (filePath.startsWith('file://')) {\r\n      normPath = Uri.parse(filePath).toFilePath();\r\n    }\r\n\r\n    final file = File(normPath);\r\n    if (await file.exists()) {\r\n      await file.delete();\r\n    }\r\n  } catch (e) {\r\n    logger.error('Error deleting file: $e');\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Checklist Before Committing Code\r\n\r\n- [ ] Code follows Dart style guide (`dart format`)\r\n- [ ] No `print()` statements (use proper logging)\r\n- [ ] All public methods have doc comments (`///`)\r\n- [ ] Error handling is implemented\r\n- [ ] Constants are extracted (no magic numbers)\r\n- [ ] Resource cleanup in `dispose()` methods\r\n- [ ] No hardcoded strings\r\n- [ ] Naming follows conventions (camelCase, PascalCase, kConstants)\r\n- [ ] Functions are single-responsibility\r\n- [ ] Comments explain WHY, not WHAT\r\n- [ ] Type safety is maintained (no unnecessary `dynamic`)\r\n- [ ] Tests pass (when added)\r\n\r\n---\r\n\r\n## Tools & Commands\r\n\r\n```bash\r\n# Format code\r\ndart format lib/\r\n\r\n# Analyze code\r\nflutter analyze\r\n\r\n# Run tests\r\nflutter test\r\n\r\n# Clean build\r\nflutter clean && flutter pub get\r\n```\r\n\r\n"
        }
    ]
}